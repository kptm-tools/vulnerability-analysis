package handlers

import (
	"context"
	"log/slog"

	"github.com/kptm-tools/common/common/enums"
	"github.com/kptm-tools/common/common/events"
	"github.com/kptm-tools/vulnerability-analysis/pkg/interfaces"
)

type NmapHandler struct {
	nmapService interfaces.INmapService
}

var _ interfaces.INmapHandler = (*NmapHandler)(nil)

func NewNmapHandler(nmapService interfaces.INmapService) *NmapHandler {
	return &NmapHandler{
		nmapService: nmapService,
	}
}

func (h *NmapHandler) RunScan(ctx context.Context, event events.ScanStartedEvent) <-chan interfaces.ServiceResult {
	c := make(chan interfaces.ServiceResult)

	go func() {
		defer close(c)

		// Parse targets from event
		var targets []string
		domains := event.GetDomainValues()
		ips := event.GetIPValues()
		targets = append(targets, domains...)
		targets = append(targets, ips...)

		// Run scan
		results, err := h.nmapService.RunScan(ctx, targets)

		// Check for context cancellation
		if ctx.Err() != nil {
			if ctx.Err() == context.Canceled {
				slog.Warn("Scan was canceled",
					slog.String("scanID", event.ScanID),
					slog.Any("targets", targets),
				)
				c <- interfaces.ServiceResult{
					ScanID:      event.ScanID,
					ServiceName: enums.ServiceNmap,
					Result:      nil,
					Err:         ctx.Err(),
				}
				return
			}
		}

		// Handle scan errors
		if err != nil {
			slog.Error("Error running nmap scan",
				slog.String("scanID", event.ScanID),
				slog.Any("error", err))
		}

		// Log results
		for _, res := range results {
			slog.Info("Nmap scan summary",
				slog.Any("target", res.Target),
				slog.Any("summary", res.Results[enums.ServiceNmap]))
		}

		// Send scan results
		c <- interfaces.ServiceResult{
			ScanID:      event.ScanID,
			ServiceName: enums.ServiceNmap,
			Result:      results,
			Err:         err,
		}
	}()

	return c

}
