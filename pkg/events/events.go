package events

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"sync"
	"time"

	"github.com/kptm-tools/common/common/enums"
	cmmn "github.com/kptm-tools/common/common/events"
	"github.com/kptm-tools/vulnerability-analysis/pkg/interfaces"
	"github.com/nats-io/nats.go"
)

// contextMap is a map used for accessing cancel functions for scans
// keys are scanID's, values are cancel functions
var contextMap sync.Map

func SubscribeToScanStarted(
	bus cmmn.EventBus,
	nmapHandler interfaces.INmapHandler,
) error {
	bus.Subscribe(string(enums.ScanStartedEventSubject), func(msg *nats.Msg) {

		go func(msg *nats.Msg) {

			slog.Info("Received ScanStartedEvent")
			// 1. Parse the message payload
			var payload cmmn.ScanStartedEvent

			if err := json.Unmarshal(msg.Data, &payload); err != nil {
				slog.Error("Received invalid JSON payload", slog.Any("payload", msg.Data))
				// 1.1 TODO: Publish scan failed (placeholder for now)
				msg, err := json.Marshal(map[string]string{"reason": "Invalid JSON payload", "payload": string(msg.Data)})
				if err != nil {
					slog.Error("Failed to marshal scan failed payload", slog.Any("error", err))
				}
				bus.Publish("ScanFailed", msg)
				return
			}

			// Cancellation context
			ctx, cancel := context.WithCancel(context.Background())
			contextMap.Store(payload.ScanID, cancel)
			defer func() {
				contextMap.Delete(payload.ScanID)
				cancel()
			}()

			slog.Debug("Received payload", slog.Any("payload", payload))
			// 2. Call our handlers for each tool
			c := nmapHandler.RunScan(ctx, payload)

			for result := range c {
				if result.Err != nil {
					slog.Error("Encountered error running Nmap Scan", slog.Any("error", result.Err))
				}
				// 3. Publish the result
				if err := processNmapResult(result, bus); err != nil {
					slog.Error("Failed to process NmapResult", slog.Any("error", err))
				}

			}
			slog.Info("Finished analyzing vulnerabilities", slog.String("scanID", payload.ScanID))

		}(msg)
	})

	return nil
}

func SubscribeToScanCancelled(bus cmmn.EventBus) error {
	bus.Subscribe(string(enums.ScanCancelledEventSubject), func(msg *nats.Msg) {
		go func(msg *nats.Msg) {

			slog.Info("Received ScanCancelledEvent")
			// 1. Parse the message payload
			var payload cmmn.ScanCancelledEvent
			if err := json.Unmarshal(msg.Data, &payload); err != nil {
				slog.Error("Received invalid JSON payload", slog.Any("payload", msg.Data))
				// 1.1 Publish scan cancelled failed?
				return
			}

			slog.Debug("Received payload", slog.Any("payload", payload))
			slog.Info("Cancelling scan", slog.String("scanID", payload.ScanID))
			if cancelFunc, ok := contextMap.Load(payload.ScanID); ok {
				cancelFunc.(context.CancelFunc)() // Cancel the context
				contextMap.Delete(payload.ScanID)
				slog.Info("Scan successfully cancelled", slog.String("scanID", payload.ScanID))
			} else {
				slog.Warn("No active scan found for ScanID", slog.String("scanID", payload.ScanID))
			}
		}(msg)
	})
	return nil
}

func processNmapResult(result interfaces.ServiceResult, bus cmmn.EventBus) error {
	subject := enums.NmapEventSubject

	slog.Info("Publishing service result", slog.String("subject", string(subject)))

	payload, err := buildNmapEventPaylod(result)
	if err != nil {
		return fmt.Errorf("failed to build NmapEvent payload: %w", err)
	}

	if err := bus.Publish(string(enums.NmapEventSubject), payload); err != nil {
		return fmt.Errorf("failed to publish NmapEvent: %w", err)
	}
	return nil

}

func buildNmapEventPaylod(result interfaces.ServiceResult) ([]byte, error) {
	// Build the payload
	timestamp := time.Now().Unix()

	var eventError *cmmn.EventError
	if result.Err != nil {
		eventError = &cmmn.EventError{
			Code:    result.Err.Error(),
			Message: result.Err.Error(),
		}
	}

	baseEvt := cmmn.BaseEvent{
		ScanID:    result.ScanID,
		Error:     eventError,
		Timestamp: timestamp,
	}

	evt := cmmn.NmapEvent{
		BaseEvent: baseEvt,
		Results:   result.Result,
	}

	bytes, err := json.Marshal(evt)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal NmapEvent payload: %w", err)
	}
	return bytes, nil
}
