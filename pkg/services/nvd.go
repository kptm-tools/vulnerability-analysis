package services

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/kptm-tools/common/common/pkg/results/tools"
	"github.com/kptm-tools/vulnerability-analysis/pkg/dto"
)

var baseNvdApiURL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

var ErrInvalidCPE = errors.New("invalid CPE name")

func fetchNvdDataByCPE(cpe string, baseNvdApiURL string) (*dto.NvdApiResponse, error) {
	// Validate CPE
	if err := isValidCPE(cpe); err != nil {
		return nil, fmt.Errorf("invalid CPE: %w", err)
	}

	// Build URL
	query := url.Values{}
	query.Set("cpeName", cpe)
	apiURL := baseNvdApiURL + "?" + query.Encode()

	resp, err := http.Get(apiURL)
	if err != nil {
		return nil, fmt.Errorf("failed NVD API request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("status error on NVD API request: %d %s", resp.StatusCode, resp.Status)
	}

	var nvdResponse dto.NvdApiResponse
	if err := json.NewDecoder(resp.Body).Decode(&nvdResponse); err != nil {
		return nil, fmt.Errorf("failed to decode NVD API response: %w", err)
	}

	return &nvdResponse, nil
}

func isValidCPE(cpe string) error {
	parts := strings.Split(cpe, ":")

	if len(parts) != 13 {
		return fmt.Errorf("%w: must have 13 colon-separated parts, got %d", ErrInvalidCPE, len(parts))
	}

	if parts[0] != "cpe" {
		return fmt.Errorf("%w: must start with 'cpe', got '%s'", ErrInvalidCPE, parts[0])
	}

	if parts[1] != "2.3" {
		return fmt.Errorf("%w: must have '2.3' as the second part (CPE Version), got '%s'", ErrInvalidCPE, parts[1])
	}

	componentsToCheck := []struct {
		index int
		name  string
	}{
		{index: 2, name: "part"},
		{index: 3, name: "vendor"},
		{index: 4, name: "product"},
		{index: 5, name: "version"},
	}

	for _, comp := range componentsToCheck {
		if parts[comp.index] == "*" {
			return fmt.Errorf("%w: %s component must not be '*'", ErrInvalidCPE, parts[comp.index])
		}
	}

	return nil
}

// standardizeCPE transforms an incomplete CPE from nmap output into a incomplete
// CPE v2.3 format to be consumed by the NVD API
func standardizeCPE(cpe string) (string, error) {
	if !strings.HasPrefix(cpe, "cpe:/") {
		return "", fmt.Errorf("CPE does not start with 'cpe:/': %s", cpe)
	}

	cpeWithoutPrefix := strings.TrimPrefix(cpe, "cpe:/")
	parts := strings.Split(cpeWithoutPrefix, ":")

	if len(parts) < 4 { // We need part, vendor, product and version as minimum
		return "", fmt.Errorf("CPE is too short, needs at least part, vendor, product and version: %s", cpe)
	}

	// Remove leading slash from 'part' component if present
	parts[0] = strings.TrimPrefix(parts[0], "/")

	// Pad with "*" to reach 11 components after "cpe" and "2.3"
	paddingNeeded := 11 - len(parts)
	if paddingNeeded > 0 {
		for i := 0; i < paddingNeeded; i++ {
			parts = append(parts, "*")
		}
	} else if paddingNeeded < 0 {
		parts = parts[:11]
	}

	standardizedCPE := "cpe:2.3:" + strings.Join(parts, ":")
	return standardizedCPE, nil
}

func enrichVulnerabilityWithNvdData(vuln *tools.Vulnerability, nvdVuln *dto.Vulnerability) error {
	vuln.ID = nvdVuln.Cve.Id
	vuln.Type = nvdVuln.Cve.SourceIdentifier // This may be the incorrect field...

	// Descriptions - first english description
	for _, desc := range nvdVuln.Cve.Descriptions {
		if desc.Lang == "en" {
			vuln.Description = desc.Value
			break
		}
	}

	// References
	var references []string
	for _, ref := range nvdVuln.Cve.References {
		references = append(references, ref.Url)
	}
	vuln.References = references

	// Metrics - Prioritize CVSS v3.1, then v3.0, then v2
	cvssScore := 0.0
	baseSeverity := ""

	if nvdVuln.Cve.Metrics != nil {
		if len(nvdVuln.Cve.Metrics.CvssMetricV31) > 0 {
			cvssScore = float64(nvdVuln.Cve.Metrics.CvssMetricV31[0].CvssData.BaseScore)
			baseSeverity = string(nvdVuln.Cve.Metrics.CvssMetricV31[0].CvssData.BaseSeverity)
			vuln.Access = string(nvdVuln.Cve.Metrics.CvssMetricV31[0].CvssData.AttackVector)
			vuln.Complexity = string(nvdVuln.Cve.Metrics.CvssMetricV31[0].CvssData.AttackComplexity)
			vuln.PrivilegesRequired = string(nvdVuln.Cve.Metrics.CvssMetricV31[0].CvssData.PrivilegesRequired)
			vuln.IntegrityImpact = string(nvdVuln.Cve.Metrics.CvssMetricV31[0].CvssData.IntegrityImpact)
			vuln.AvailabilityImpact = string(nvdVuln.Cve.Metrics.CvssMetricV31[0].CvssData.AvailabilityImpact)
			vuln.BaseSeverity = baseSeverity
		} else if len(nvdVuln.Cve.Metrics.CvssMetricV30) > 0 {
			cvssScore = float64(nvdVuln.Cve.Metrics.CvssMetricV30[0].CvssData.BaseScore) // Fallback to v3.0 if v3.1 not available
			baseSeverity = string(nvdVuln.Cve.Metrics.CvssMetricV30[0].CvssData.BaseSeverity)
			vuln.Access = string(nvdVuln.Cve.Metrics.CvssMetricV30[0].CvssData.AttackVector)         // Map Attack Vector to Access
			vuln.Complexity = string(nvdVuln.Cve.Metrics.CvssMetricV30[0].CvssData.AttackComplexity) // Map Attack Complexity to Complexity
			vuln.PrivilegesRequired = string(nvdVuln.Cve.Metrics.CvssMetricV30[0].CvssData.PrivilegesRequired)
			vuln.IntegrityImpact = string(nvdVuln.Cve.Metrics.CvssMetricV30[0].CvssData.IntegrityImpact)
			vuln.AvailabilityImpact = string(nvdVuln.Cve.Metrics.CvssMetricV30[0].CvssData.AvailabilityImpact)
			vuln.BaseSeverity = baseSeverity // Base Severity from v3.0
		} else if len(nvdVuln.Cve.Metrics.CvssMetricV2) > 0 {
			cvssScore = nvdVuln.Cve.Metrics.CvssMetricV2[0].CvssData.BaseScore // Fallback to v2 if v3 not available
			baseSeverity = nvdVuln.Cve.Metrics.CvssMetricV2[0].BaseSeverity
			vuln.Access = string(nvdVuln.Cve.Metrics.CvssMetricV2[0].CvssData.AccessVector)         // Map Access Vector to Access
			vuln.Complexity = string(nvdVuln.Cve.Metrics.CvssMetricV2[0].CvssData.AccessComplexity) // Map Access Complexity to Complexity
			vuln.IntegrityImpact = string(nvdVuln.Cve.Metrics.CvssMetricV2[0].CvssData.IntegrityImpact)
			vuln.AvailabilityImpact = string(nvdVuln.Cve.Metrics.CvssMetricV2[0].CvssData.AvailabilityImpact)
			vuln.BaseSeverity = baseSeverity // Base Severity from v2
		}
	}
	vuln.BaseCVSSScore = cvssScore

	// Exploitability
	vuln.Exploitable = false // Placeholder - needs more sophisticated logic

	// Published and Updated Dates
	publishedTime, err := time.Parse(time.RFC3339, nvdVuln.Cve.Published)
	if err == nil {
		vuln.Published = publishedTime.Format("01/02/2006")
	}
	updatedTime, err := time.Parse(time.RFC3339, nvdVuln.Cve.LastModified)
	if err == nil {
		vuln.LastUpdated = updatedTime.Format("01/02/2006")
	}

	// Risk Score and Likelihood - Map from CVSS ImpactScore ifavailable, otherwise default
	if nvdVuln.Cve.Metrics != nil {
		if len(nvdVuln.Cve.Metrics.CvssMetricV31) > 0 {
			vuln.ImpactScore = nvdVuln.Cve.Metrics.CvssMetricV31[0].ImpactScore
		} else if len(nvdVuln.Cve.Metrics.CvssMetricV30) > 0 {
			vuln.ImpactScore = nvdVuln.Cve.Metrics.CvssMetricV30[0].ImpactScore
		} else if len(nvdVuln.Cve.Metrics.CvssMetricV2) > 0 {
			vuln.ImpactScore = nvdVuln.Cve.Metrics.CvssMetricV2[0].ImpactScore
		} else {
			vuln.ImpactScore = 0
		}
	} else {
		vuln.ImpactScore = 0 // Default if no impact score is found
	}

	return nil
}
