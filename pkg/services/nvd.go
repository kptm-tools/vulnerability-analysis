package services

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/kptm-tools/vulnerability-analysis/pkg/dto"
)

var baseNvdApiURL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

var ErrInvalidCPE = errors.New("invalid CPE name")

func fetchNvdDataByCPE(cpe string, baseNvdApiURL string) (*dto.NvdApiResponse, error) {
	// Validate CPE
	if err := isValidCPE(cpe); err != nil {
		return nil, fmt.Errorf("invalid CPE: %w", err)
	}

	// Build URL
	query := url.Values{}
	query.Set("cpeName", cpe)
	apiURL := baseNvdApiURL + "?" + query.Encode()

	resp, err := http.Get(apiURL)
	if err != nil {
		return nil, fmt.Errorf("failed NVD API request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("status error on NVD API request: %d %s", resp.StatusCode, resp.Status)
	}

	var nvdResponse dto.NvdApiResponse
	if err := json.NewDecoder(resp.Body).Decode(&nvdResponse); err != nil {
		return nil, fmt.Errorf("failed to decode NVD API response: %w", err)
	}

	return &nvdResponse, nil
}

func isValidCPE(cpe string) error {
	parts := strings.Split(cpe, ":")

	if len(parts) != 13 {
		return fmt.Errorf("%w: must have 13 colon-separated parts, got %d", ErrInvalidCPE, len(cpe))
	}

	if parts[0] != "cpe" {
		return fmt.Errorf("%w: must start with 'cpe', got '%s'", ErrInvalidCPE, parts[0])
	}

	if parts[1] != "2.3" {
		return fmt.Errorf("%w: must have '2.3' as the second part (CPE Version), got '%s'", ErrInvalidCPE, parts[1])
	}

	componentsToCheck := []struct {
		index int
		name  string
	}{
		{index: 2, name: "part"},
		{index: 3, name: "vendor"},
		{index: 4, name: "product"},
		{index: 5, name: "version"},
	}

	for _, comp := range componentsToCheck {
		if parts[comp.index] == "*" {
			return fmt.Errorf("%w: %s component must not be '*'", ErrInvalidCPE, parts[comp.index])
		}
	}

	return nil
}
