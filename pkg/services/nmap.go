package services

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/Ullaakut/nmap/v2"
	"github.com/Ullaakut/nmap/v2/pkg/osfamilies"
)

type NmapResult struct {
	HostName     *string    `json:"host_name"`
	HostAddress  *string    `json:"host_address"`
	ScannedPorts []PortData `json:"scanned_ports"`
	OSFamily     string     `json:"os_family"`
}

type PortData struct {
	ID       uint16  `xml:"portid,attr" json:"id"`
	Protocol string  `xml:"protocol,attr" json:"protocol"`
	Service  Service `xml:"service" json:"service"`
	Product  string  `xml:"product" json:"product"`
	State    string  `xml:"state" json:"state"`
}

type Service struct {
	Name       string `json:"name"`
	Version    string `json:"version"`
	Confidence int    `json:"confidence"`
}

type Vulnerability struct {
	ID         string   `json:"id"`
	CVSS       float64  `json:"cvss"`
	References []string `json:"reference"`
	HasExploit bool     `json:"has_exploit"`
}

func (r *NmapResult) String() string {
	data, err := json.MarshalIndent(r, "", " ")
	if err != nil {
		return ""
	}
	return string(data)
}

func RunNmapScan(targets []string) (*NmapResult, error) {
	fmt.Println("Running nmap scanner...")

	timeout := 240 * len(targets)
	ctx, cancel := context.WithTimeout(
		context.Background(),
		time.Duration(timeout)*time.Second,
	)
	defer cancel()

	scanner, err := nmap.NewScanner(
		nmap.WithTargets(targets...),
		nmap.WithMostCommonPorts(100),
		nmap.WithServiceInfo(),
		nmap.WithOSDetection(),
		nmap.WithOSScanGuess(),
		nmap.WithContext(ctx),
	)
	if err != nil {
		return nil, err
	}

	res, warnings, err := scanner.Run()
	if warnings != nil {
		log.Printf("Warnings: %+v\n", warnings)
	}

	if err != nil {
		if ctx.Err() == context.DeadlineExceeded {
			return nil, fmt.Errorf("scan timeout after %d seconds", timeout)
		}
		return nil, fmt.Errorf("scan error: %w", err)
	}

	for _, host := range res.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			log.Printf("No ports or addressed found")
			continue
		}

		h := &NmapResult{
			HostName:    parseHostName(host),
			HostAddress: parseHostAddress(host),
		}

		log.Printf("Host %q:\n", host.Addresses[0])

		for _, port := range host.Ports {
			p := PortData{
				ID:       port.ID,
				Protocol: port.Protocol,
				Service: Service{
					Name:       port.Service.Name,
					Version:    port.Service.Version,
					Confidence: port.Service.Confidence,
				},
				Product: port.Service.Product,
				State:   port.State.State,
			}

			h.ScannedPorts = append(h.ScannedPorts, p)
		}
		log.Printf("Parsed host: \n%s\n", h)
	}

	for _, host := range res.Hosts {
		os := getMostLikelyOS(host)
		log.Printf("Most likely OS: %s", os)
	}

	log.Printf("Nmap done: %d hosts up scanned in %3f seconds\n", len(res.Hosts), res.Stats.Finished.Elapsed)

	return nil, nil
}

// getMostLikelyOS checks for most likely OS considering TCP matches
func getMostLikelyOS(host nmap.Host) string {
	var windows, linux int

	for _, match := range host.OS.Matches {
		log.Printf("\tOS name: %s \n", match.Name)
		for _, class := range match.Classes {
			switch class.OSFamily() {
			case osfamilies.Linux:
				linux++
			case osfamilies.Windows:
				windows++
			}
		}
	}

	if linux > windows {
		return "Linux"
	} else if windows > linux {
		return "Windows"
	}
	return ""
}

func parseHostName(host nmap.Host) *string {
	// If host type is IP, we won't get a Hostname
	var hostName *string

	if len(host.Hostnames) > 0 {
		hostName = &host.Hostnames[0].Name
	}

	return hostName
}

func parseHostAddress(host nmap.Host) *string {
	var hostAddress *string

	if len(host.Addresses) > 0 {
		hostAddress = &host.Addresses[0].Addr
	}

	return hostAddress
}
