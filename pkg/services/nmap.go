package services

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"strconv"
	"strings"
	"time"

	"github.com/Ullaakut/nmap/v2"
	"github.com/kptm-tools/common/common/results"
	"github.com/kptm-tools/vulnerability-analysis/pkg/config/interfaces"
)

type NmapService struct {
	Logger *slog.Logger
}

type NmapResult struct {
	HostName     string     `json:"host_name"`
	HostAddress  string     `json:"host_address"`
	ScannedPorts []PortData `json:"scanned_ports"`
	MostLikelyOS string     `json:"most_likely_os"`
}

type PortData struct {
	ID              uint16          `xml:"portid,attr" json:"id"`
	Protocol        string          `xml:"protocol,attr" json:"protocol"`
	Service         Service         `xml:"service" json:"service"`
	Product         string          `xml:"product" json:"product"`
	State           string          `xml:"state" json:"state"`
	Vulnerabilities []Vulnerability `xml:"vulnerabilities" json:"vulnerabilities"`
}

type Service struct {
	Name       string `json:"name"`
	Version    string `json:"version"`
	Confidence int    `json:"confidence"`
}

type Vulnerability struct {
	ID          string   `json:"id"`
	Type        string   `json:"type"`
	CVSS        float64  `json:"cvss"`
	References  []string `json:"reference"`
	Exploitable bool     `json:"has_exploit"`
}

func (r *NmapResult) String() string {
	data, err := json.MarshalIndent(r, "", " ")
	if err != nil {
		return ""
	}
	return string(data)
}

var _ interfaces.INmapService = (*NmapService)(nil)

func NewNmapService() *NmapService {
	return &NmapService{
		Logger: slog.New(slog.Default().Handler()),
	}

}

func (s *NmapService) RunScan(targets []string) ([]results.TargetResult, error) {
	fmt.Println("Running nmap scanner...")

	timeout := 240 * len(targets)
	ctx, cancel := context.WithTimeout(
		context.Background(),
		time.Duration(timeout)*time.Second,
	)
	defer cancel()

	scanner, err := nmap.NewScanner(
		nmap.WithTargets(targets...),
		nmap.WithMostCommonPorts(100),
		nmap.WithServiceInfo(),
		nmap.WithSkipHostDiscovery(),
		nmap.WithOSDetection(),
		nmap.WithOSScanGuess(),
		nmap.WithScripts("vulners"),
		nmap.WithContext(ctx),
	)
	if err != nil {
		return nil, err
	}

	res, warnings, err := scanner.Run()
	if warnings != nil {
		s.Logger.Warn("Nmap raised warnings:", "nmap_warnings", warnings)
	}

	if err != nil {
		if ctx.Err() == context.DeadlineExceeded {
			return nil, fmt.Errorf("scan timeout after %d seconds", timeout)
		}
		return nil, fmt.Errorf("scan error: %w", err)
	}

	s.Logger.Info("Nmap done: ", "hosts_up", len(res.Hosts), "time_elapsed", res.Stats.Finished.Elapsed)

	results := s.procesScanResults(res)

	return results, nil
}

func (s *NmapService) procesScanResults(res *nmap.Run) []results.TargetResult {
	var targetResults []results.TargetResult

	for _, host := range res.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			s.Logger.Warn("No ports or addressed found", "host", host)
			continue
		}

		h := &NmapResult{
			HostName:    parseHostName(host),
			HostAddress: parseHostAddress(host),
		}

		// OS Detection
		os := getMostLikelyOS(host)
		h.MostLikelyOS = os

		for _, port := range host.Ports {
			p := PortData{
				ID:       port.ID,
				Protocol: port.Protocol,
				Service: Service{
					Name:       port.Service.Name,
					Version:    port.Service.Version,
					Confidence: port.Service.Confidence,
				},
				Product: port.Service.Product,
				State:   port.State.State,
			}

			for _, script := range port.Scripts {

				vulns, err := s.ParseVulnersScript(script)
				if err != nil {
					s.Logger.Error("Error parsing Vulners Script", "error", err)
					continue
				}

				p.Vulnerabilities = append(p.Vulnerabilities, vulns...)
			}

			h.ScannedPorts = append(h.ScannedPorts, p)
		}
		s.Logger.Debug("Parsed host", "host", h)

		targetResult := results.TargetResult{
			Target:  h.String(),
			Results: map[results.ServiceName]interface{}{results.ServiceNmap: h},
		}
		targetResults = append(targetResults, targetResult)

	}

	return targetResults

}

// getMostLikelyOS checks for most likely OS considering TCP matches
func getMostLikelyOS(host nmap.Host) string {
	if len(host.OS.Matches) == 0 {
		return ""
	}

	mostLikely := ""
	maxAccuracy := 0
	for _, match := range host.OS.Matches {
		if match.Accuracy > maxAccuracy {
			mostLikely = match.Name
			maxAccuracy = match.Accuracy
		}
	}

	return mostLikely
}

func parseHostName(host nmap.Host) string {
	// If host type is IP, we won't get a Hostname
	var hostName string

	if len(host.Hostnames) > 0 {
		hostName = host.Hostnames[0].Name
	}

	return hostName
}

func parseHostAddress(host nmap.Host) string {
	var hostAddress string

	if len(host.Addresses) > 0 {
		hostAddress = host.Addresses[0].Addr
	}

	return hostAddress
}

func (s *NmapService) ParseVulnersScript(script nmap.Script) ([]Vulnerability, error) {
	if script.ID != "vulners" {
		return nil, fmt.Errorf("script ID is not 'vulners': %s", script.ID)
	}

	var vulnerabilities []Vulnerability

	for _, table := range script.Tables {
		for _, subTable := range table.Tables {

			vulnMap := map[string]string{}
			for _, element := range subTable.Elements {
				// Store elements in a temporary Map
				vulnMap[element.Key] = element.Value
			}

			// Build Vulnerability Struct
			if id, exists := vulnMap["id"]; exists {
				var vuln Vulnerability
				vuln.ID = id

				// Parse Type
				if typeStr, ok := vulnMap["type"]; ok {
					vuln.Type = typeStr
				}

				// Parse CVSS
				if cvssStr, ok := vulnMap["cvss"]; ok {
					cvss, err := strconv.ParseFloat(strings.TrimSpace(cvssStr), 64)
					if err != nil {
						s.Logger.Error("Error parsing CVSS", "port_id", id, "error", err)
					} else {
						vuln.CVSS = cvss
					}
				}

				// Parse Exploitable
				if exploitableStr, ok := vulnMap["is_exploit"]; ok {
					exploitable, err := strconv.ParseBool(exploitableStr)
					if err != nil {
						s.Logger.Error("Error parsing is_exploit", "port_id", id, "error", err)
					} else {
						vuln.Exploitable = exploitable
					}
				}

				vuln.BuildVulnersReferences()
				vulnerabilities = append(vulnerabilities, vuln)
			}

		}
	}

	return vulnerabilities, nil
}

func (v *Vulnerability) BuildVulnersReferences() {
	if v.Type != "" && v.ID != "" {
		reference := buildVulnersReference(v.ID, v.Type)
		v.References = append(v.References, reference)
	}
}

func buildVulnersReference(id, vulnType string) string {
	return fmt.Sprintf("https://vulners.com/%s/%s", vulnType, id)
}
